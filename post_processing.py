"""
Post-processing for the algorithm:
Selects the best bike network given the data generated by the algorithm.
"""
import osmnx as ox
import numpy as np
import networkx as nx
import osmnx as ox
from helper.current_state_helper import calc_empty_state


def format_mode(mode):
    flags = []
    if mode[0]:
        flags.append('rev')
    flags.append('minmode ' + str(mode[1]))  # minmode
    # how to display build methods
    bm_dict = {
        0: 'Monte Carlo',
        1: 'MFT',
        2: 'Heat',
        3: '2f1b'
    }
    flags.append(bm_dict[mode[3]])
    cost_dict = {
        0: 'equal cost',
        1: 'weighted cost'
    }
    flags.append(cost_dict[mode[5]])
    return ', '.join(flags)


def load_data(place, mode):
    data = np.load('data/algorithm/output/{}_data_mode_{:d}{}{}{}.npy'
                   .format(place, mode[0], mode[1], mode[3], mode[5]),
                   allow_pickle=True)
    trip_nbrs = np.load('data/algorithm/input/{}_demand.npy'.format(place),
                        allow_pickle=True)[0]
    G = load_graph(place)
    empty_state = calc_empty_state(G, trip_nbrs)
    d = {}
    d['edited edges'] = data[0]
    d['edited edges nx'] = data[1]
    d['total cost'] = data[2]
    d['bike lane perc'] = data[3]
    d['total real distance traveled'] = data[4]
    d['total felt distance traveled'] = data[5]
    d['nbr on street'] = data[6]
    d['len saved'] = data[7]
    d['nbr of cbc'] = data[8]
    d['gcbc size'] = data[9]
    d['edge action'] = data[10]
    d['bikeability'] = calculate_bikeability(
        d['total real distance traveled'],
        empty_state=empty_state['total real distance traveled'])
    d['felt bikeability'] = calculate_bikeability(
        d['total felt distance traveled'],
        empty_state=empty_state['total felt distance traveled'])
    d['iteration'] = list(range(len(d['bikeability'])))
    # "unpack" the dictionaries 'total real distance traveled' and 'total felt
    # distance traveled'
    # goal: entries like d['total felt length on street'] return what you expect
    #       (that is: [t['total length on street']
    #                  for t in d['total felt distance traveled']])
    # step 1: transform list of dicts -> dict of lists
    tdt_dict = {}
    for rf in ('real', 'felt'):
        tdt_dict[rf] = {}
        for key in d['total ' + rf + ' distance traveled'][0]:
            tdt_dict[rf][key] = [t[key] for t
                                 in d['total ' + rf + ' distance traveled']]
    # step 2: unpack the tdt_dict into d
    for rf in ('real', 'felt'):
        for key, val in tdt_dict[rf].items():
            # key is something like 'total length on all'
            # val is a list
            d_key = key.replace('total length', 'total ' + rf + ' length')
            d[d_key] = val
    return d, G, trip_nbrs


def load_graph(place):
    G = ox.load_graphml('{}.graphml'.format(place),
                        folder='data/algorithm/input', node_type=int)
    G = G.to_undirected()
    return G


def apply_edge_operations(G, edited_edges, edge_action):
    """
    Apply the operations listed in edited_edges and edge_action to G. Starts by
    assuming there is a bike lane everywhere (nx.set_edge_attributes(G, True,
    'bike lane')).
    :param G: networkx graph
    :type edge_action: list of bools
    :return: modified networkx graph
    """
    nx.set_edge_attributes(G, True, 'bike lane')
    for changed_edge, change_action in zip(edited_edges, edge_action):
        G.edges[(*changed_edge, 0)]['bike lane'] = change_action
    return G


def calculate_bikeability(total_distance_traveled, empty_state=None):
    """
    Calculate the bikeability.
    :param total_distance_traveled: a list (each entry is generated in one
    iteration of the algorithm) of dictionaries, which each save the total
    length cyclists have to drive on each street type. Note: 'total length on
    street' is the sum of 'total length on
    {primary|secondary|tertiary|residential}' and 'total length on bike lane' is
    'total length on all' minus 'total length on street'.
    :param empty_state: If not None, this argument is used to "norm" the
    bikeability. In runs where the algorithm does not hit a "no bike
    lanes"-network, the bikeability gets to zero for a network which might have
    some good bike lanes. empty_state is assumed to be the entry
    'total_distance_traveled' of a street network with no bike lanes (see also
    calc_empty_state of current_state_helper.py)
    """
    if empty_state is not None:
        tdt = total_distance_traveled + [empty_state]
    else:
        tdt = total_distance_traveled
    max_dist_on_all = max({t['total length on all']
                           for t in tdt})
    norm_dist_on_all = [t['total length on all'] / max_dist_on_all
                        for t in tdt]
    max_norm = max(norm_dist_on_all)
    min_norm = min(norm_dist_on_all)
    bikeability = [1 - (t - min_norm) / (max_norm - min_norm)
                   for t in norm_dist_on_all]
    if empty_state is not None:
        return bikeability[:-1]  # cut off last element
    else:
        return bikeability


def get_best_graph(place, mode):
    """
    Return the networkx graph G with the best bikeability.
    """
    data, G, _ = load_data(place, mode)
    bikeability = calculate_bikeability(data['total real distance traveled'])
    # set bikeability to 0 for all configurations that cost more than our budget
    # -- because bike paths are worth nothing if they can't be built!
    budget = mode[2]
    bikeability = [0 if cost > budget else ba
                   for cost, ba in zip(data['total cost'], bikeability)]
    max_bikeability_index = np.argmax(bikeability)
    apply_edge_operations(G, data['edited edges nx'][:max_bikeability_index+1],
                          data['edge action'][:max_bikeability_index+1])
    return G, max_bikeability_index


def first_road_built_index(data):
    """
    Determine the iteration in which the first road was built. This is useful to
    differentiate if the optimum was reached by the classic minimization
    strategy, or by the building of roads later.
    """
    idcs = np.nonzero(data['edge action'])[0]
    if len(idcs) == 0:
        return len(data['edge action'])
    return np.min(np.nonzero(data['edge action'])[0])


def show_summary(place, modes):
    """
    For all modes, print a quick summary (which bikeability they can reach with
    the given budget).
    """
    for mode in modes:
        data, G, _ = load_data(place, mode)
        print("Mode: {}, budget {:.02f}, first bike lane built @ iter. {} (total {})"
              .format(format_mode(mode), mode[2], first_road_built_index(data), len(data['edge action'])))
        for ba in ['bikeability', 'felt bikeability']:
            # np.where sets bikeability to zero if the total cost is greater
            # than mode[2]
            bikeability = np.where(np.array(data['total cost']) <= mode[2],
                                   data[ba], 0)
            max_ba_idx = np.argmax(bikeability)
            max_ba = data[ba][max_ba_idx]
            print("  max {}: {:.01f}% @ iter. {}"
                  .format(ba, max_ba*100, max_ba_idx))
